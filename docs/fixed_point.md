# fixed_point.py

本说明文档用于解释 `fixed_point.py` 的整体设计思想。该模块用于在含环路的电路中，通过数值不动点迭代求解占位符 (`__ph__{wire}`) 的稳态概率。

---

## 1. 问题背景

在有环路的组合逻辑电路中，某些 wire 的值依赖自身（通过反馈路径）。  
CellIterator 在第一次“拓扑传播”过程中会检测到这些反馈边，并注入占位符变量 `__ph__{wire}`。

对于这样的 wire，它的概率满足一个自洽方程：

\[
P(W) = P( F_W(PIs, W) )
\]

其中 `F_W` 是该 wire 的驱动器输出口的 BDD 布尔函数。

这就变成了一个**不动点求解问题**。

---

## 2. 求解目标

我们需要一个函数：
\[
solve_placeholders(...) → dict
\]

返回

{
"__ph__N22": 0.37,
"__ph__N44": 0.58,
...
}


---

## 3. 性能

如果对每个 placeholder 都单独递归计算概率，那么会反复遍历同一个 BDD 子图，性能会非常糟糕。

为解决这个问题，我们采用以下策略：

| 优化点 | 作用 |
|--------|------|
| 将所有 driver functions 联合成**单个全局 BDD DAG** | 避免重复遍历 |
| 对该 DAG 做一次逆拓扑排序 | 能在一次 pass 内计算所有节点概率 |
| 所有概率存入数组，用整数索引取代哈希查找 | 显著加速 |
| varname 预处理成 PH / PI 两类 | 直接映射，无需字符串匹配 |
| 补边（complemented edge）不复制节点，只做符号处理 | 更紧凑更快 |
| 可选的 Anderson 加速 | 收敛更快，防止震荡 |

---

## 4. 迭代逻辑（Picard 不动点）

迭代流程：

1. 用当前 p(__ph__) 向模型注入占位符值
2. 对整个 BDD DAG 执行一次概率 DP：**O(N)**
3. 读取每个 driver function 的概率作为 `g(p)`
4. 使用欠松弛更新：
   \[
   p_{new} = (1-damp)*p + damp*g
   \]
5. 若 \|p_new - p_old\|_\infty < tol → 收敛

可选：在 (3) 与 (4) 之间加 Anderson 加速，减少迭代轮数
